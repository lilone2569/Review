指令：
常用的Linux指令
1、怎么查看当前进程？怎么执行退出？怎么查看当前路径？
ps –aux查询当前系统下（进程的状态）
ps –ef ---查询当前系统下（父子进程关系）
执行退出：exit
查看当前路径：pwd

2、ls 命令执行什么功能？可以带哪些参数，有什么区别？
列出当前目录下的文件以及文件夹
ls -a:显示当前目录所有文件以及文件夹
ls -l:以长格式显示文件和目录信息，包括权限、所有者、大小、创建时间等
ls -d:只列出目录

3、创建目录用什么命令？
mkdir 
mkdir -p file  -p可以跨目录创建


4、创建文件用什么命令？
vi/vim
echo "hello" > 1.txt   创建文件并且将hello覆盖写入
echo "helo" >> 1.txt 在已有的文件中追加写入
touch




5、复制文件用什么命令？
cp


6、查看文件内容有哪些命令可以使用？
vi 文件名 #编辑方式查看，可修改
cat 文件名 #显示全部文件内容
more 文件名 #分页显示文件内容
less 文件名 #与more 相似，更好的是可以往前翻页
tail 文件名 #仅查看尾部，还可以指定行数
head 文件名 #仅查看头部,还可以指定行数


7、怎么向屏幕输出带空格的字符串，比如”hello world”?
echo

8、移动文件用哪个命令？改名用哪个命令？
mv，改名使用mv或者rename都可以


9、删除文件用哪个命令？如果需要连目录及目录下文件一块删除呢？删除空文件夹用什么命令？
rm ,rm -r,rmdir


10、查找文件内容用哪个命令？
grep是根据文件的内容进行查找，会对文件的每一行按照给定的模式(patter)进行匹配查找。
grep test *file#在当前目录中，查找后缀有 file 字样的文件中包含 test 字符串的文件，并打印出该字符串的行
grep -r update /etc/acpi #查找指定目录/etc/acpi 及其子目录 (如果存在子目录的话) 下所有文件中包含字符串"update"的文件
grep -v test *test* #查找文件名中包含 test 的文件中不包含test 的行

11、查找文件用哪个命令？
	  (1)find命令是根据文件的属性进行查找，如文件名，文件大小，所有者，所属组，是否为空，访问时间，修改时间等。 
	find . name #将当前目录及其子目录下所有文件后缀为 .c 的文件列出来
	find  . -ctime -20 #将当前目录及其子目录下所有最近 20 天内更新过的文件列出
                

                  (3)which       查看可执行文件的位置 ，只有设置了环境变量的程序才可以用

                  (4)whereis    寻找特定文件，只能用于查找二进制文件、源代码文件和man手册页

                  (5)locate       配合数据库查看文件位置 ,详情：locate -h查看帮助信息



12、cat命令
cat -n textfile #把 textfilel 的文档内容加上行号后输入到屏幕
cat -n textfile > textfile2 #把 textfilel 的文档内容加上行号后输入 textfile2 这个文档里
cat -b textfile textfile2 >> textfile3 #把 textfile 和 textfile2 的文档内容加上行号(空白行不加) 之后将内容附加到 textfile3 文档里cat /dev/nul1 > /etc/test.txt #清空 /etc/test.txt 文档内容

13、常用的GCC指令


14、预处理
gcc E test.c -o test.i    #把预处理的结果导出到test.i

15、编译为汇编代码
gcc -S test.i -o test.s   #编译器将test.i 翻译成汇编，将结果存储到test.s文件里

16、汇编
gcc -c test.s -o test.o   #将汇编代码编译为目标文件但不链接

17、链接
gcc test.o -o test  #将.o文件链接成可执行文件

18、一步到位编译
gcc test.c -o test

19、多文件编译
gcc test1.c test2.c -o test

20、警告处理
gcc -w test.c -o test    #忽略编译时的警告
gcc -Wall test.c -o test   #编译后显示所有的警告
gcc -Werror test.c -o test   #在产生警告的地方停止编译




21、常用的GDB调试指令
gdb test
#启动调试
help #查看命令帮助，具体命令查询在gdb中输入help + 命令简写h
run #重新开始运行文件 (run-text: 加载文本文件，run-bin: 加载二进制文件) ,简写r
start #单步执行，运行程序，停在第一执行语句
list #查看原代码 (list-n,从第n行开始查看代码。list+ 函数名: 查看具体函数) ,简写l
set #设置变量的值
next #单步调试(逐过程，函数直接执行)，简写n
step #单步调试(逐语句: 跳入自定义函数内部执行) 简写sbacktrace #查看函数的调用的栈帧和层级关系，简写btframe #切换函数的栈顺，简写f
info #查看函数内部局部变量的数值，简写i
finish #结束当前函数，返回到函数调用点
continue #继续运行，简写c
print #打印值及地址，简写p
quit #退出gdb,简写q
break+num #在第num行设置断点，简写b
info breakpoints #查看当前设置的所有断点
delete breakpoints num #删除第num个断点,简写d
display #追踪查看具体变量值
undisplay #取消追踪观察变量
watch #被设置观察点的变量发生修改时，打印显示
i watch #显示观察点
enable breakpoints #启用断点disable breakpoints #禁用断点
x #查看内存x/20xw 显示20个单元，16进制，4字节每单元
run argv[l] argv[2] #调试时命令行传参
set follow-fork-mode child #Makefile项目管理: 选择跟踪父子进程(fork())


22、常用的驱动开发指令


23、加载/卸载驱动
insmod/modprobe  加载驱动
rmmod  卸载驱动


24、Linux驱动如何查看驱动模块中打印信息？
dmesg

25、如何查看内核中已有的字符设备的信息？
lsmod可以查看模块的依赖关系，modprobe在加载模块时会加载其他依赖的模块。


26、如何查看正在使用的有哪些中断号？
cat /proc/interrupt





uboot：
1、什么是bootloader？
Linux系统要启动就必须需要一个 bootloader程序，也就说芯片上电以后先运行一段bootloader程序.这段 bootloader程序会先初始化时钟，看门狗，中断，SDRAM，等外设，然后将 Linux内核从 flash(NAND,NOR FLASH,SD,MMC等) 拷贝到SDRAM中，最后启动Linux内核。当然了，bootloader的实际工作要复杂的多，但是它最主要的工作就是启动 Linux内核。
bootloader和 Linux内核的关系就跟PC上的BIS和 Windows的关系一样，bootloader就相当于BIOS。总得来说，Bootloader就是一小段程序，它在系统上电时开始执行，初始化硬件设各、准备好软件环境，最后调用操作系统内核。

2、uboot启动过程中做了那些事？
第一阶段
初始化时钟，关闭看门狗，关中断，启动ICACHE，关闭DCACHE和TLB，关闭MMU，初始化SDRAM，初始化NAND FLASH，重定位。
第二阶段
初始化一个串口，检测系统内存映射，将内核映象和根文件系统映象从 Flash上读到SDRAM空间中，为内核设置启动参数，调用内核。



3、为什么要给内核传递参数呢？
在此之前，uboot已经完成了硬件的初始化，可以说已经”适应了”这块开发板。然而，内核并不是对于所有的开发板都能完美适配的(如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以完美的适配各种开发板)，此时，对于开发板的环境一无所知。所以，要想启动Linux内核，uboot必须要给内核传递一些必要的信息来告诉内核当前所处的环境。


4、uboot和内核如何完成参数传递？
在此之前，uboot已经完成了硬件的初始化，可以说已经”适应了”这块开发板。然而，内核并不是对于所有的开发板都能完美适配的(如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以完美的适配各种开发板)，此时，对于开发板的环境一无所知。所以，要想启动Linux内核，uboot必须要给内核传递一些必要的信息来告诉内核当前所处的环境。
R2存放的是块内存的基地址，这块内存中存放的是uboot给Linux内核的其他参数。这些参数有内存的起始地址、内存大小、Linux内核启动后挂载文件系统的方式等信息。很明显，参数有多个，不同的参数有不同的内容，为了让Linux内核能精确的解析出这些参数，双方在传递参数的时候要求参数在存放的时猴需要按照双方规定的格式存放
除了约定好参数存放的地址外，还要规定参数的结构。Linux2.4.x以后的内核都期望以标记列表(tagged list)的形式来传递启动参数。标记，就是一种数据结构;标记列表，就是挨着存放的多个标记。标记列表以标记 ATAG CORE 开始，以标记 ATAG NONE 结束
标记的数据结构为tag，它由一个tag header结构和一个联合 (union) 组成tag header结构表示标记的类型及长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合(union)，比如表示内存时使用tag_mem32，表示命令行时使用 tag cmdline。具体代码见arch/arm/include/asm/setup.h.
从上面可以看出，struct_tag结构体由structtag header+联合体union构成，结构体struct tag header用来描述每个tag的头部信息，如tag的类型，tag大小。联合体union用来描述每个传递给Linux内核的参数信息。


5、cache的定位
cache是位于主存(即是内存)与CPU内部的寄存器之间的一个存储设施，用来加快cpu与内存之间
数据与指令的传输速率，从而加快处理的速度。


6、为什么uboot要关掉cache？
根据cache的定位可以看出来，它是用来加快cpu从内存中取出指令的速度，但我们都知道，在设备
上电之初，我们的内存初始化比较慢一拍，当cpu初始化了，但内存还没准备好之后，就对内存进行数据
读，那么势必会造成了指令取址异常，系统就会挂了。所以，在u-boot的上电之初，就得关闭掉数据cache,
指令的cache关闭与不关闭没有太大的关系。


7、什么是MMU？
MMU(Memory Management Unit)主要用来管理虚拟存储器、物理存储器的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权、多任务多进程操作系统。


9、为啥要关闭ＭＭＵ呢？（uboot引导内核启动时）
mmu在设备上电之初是没有任何作用的，也就是说，在u-boot的初始化之初执行汇编的那一段代码中，
包括后面的初始化一些具体的外设时，访问的都是实际的地址，mmu的打开起不到任何的意义，为了不影响启动之初
对程序的启动，关闭掉mmu设备是常用的做法。






文件系统
1、什么是根文件系统？
根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，但是相对于普通的文件系统，它的特殊之处在于，它是内核启动时所挂载 (mount) 的第一个文件系统，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些初始化脚本(如rcS,inittab)和服务加载到内存中去运行，里面包含了 Linux系统能够运行所必需的应用程序、库等，比如可以给用户提供操作 Linux的控制界面的shell程序、动态连接的程序运行时需要的glibc库等。
我们要明白文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。

2、根文件系统为什么这么重要？
根文件系统之所以在前面加一个"根”，说明它是加载其它文件系统的"根"，那么如果没有这个根，其它的文件系统也就没有办法进行加载的。根文件系统包含系统启动时所必须的目录和关键性的文件，以及使其他文件系统得以挂载 (mount) 所必要的文件。例如:
init进程的应用程序必须运行在根文件系统 上。
根文件系统提供了根目录“/"。
linux挂载分区时所依赖的信息存放于根文件系统/etc/fstab这个文件中
shell命令程序必须运行在根文件系统上，譬如ls、cd等命令。
总之:一套linux体系，只有内核本身是不能工作的，必须要rootfs (上的etc目录下的配置文件、/bin/sbin等目录下的shell命令，还有/lib目录下的库文件等) 相配合才能工作。


3、可执行映像文件通常由几部分构成，它们有什么特点？


4、 Linux 是通过什么组件来实现支持多种文件系统的？
VFS(virtual file system)

5、 Linux虚拟文件系统的关键数据结构有哪些？（至少写出4个）
super_block超级块
inode索引节点
dentry目录项
file文件


6、对文件系统的操作函数保存在哪个数据结构中？
struct file_operations


7、Linux 中的文件包括哪些？
普通文件类型 [-]
目录文件[d]
块设备文件[b]
字符设备[c]
套接字文件[s]
管道文件 [p]
链接文件[l]



中断
1、硬中断 / 软中断是什么？有什么区别？
(1) 硬中断
硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的IRQ(中断请求)。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上(注: 硬件驱动通常是内核中的一个子程序，而不是一个独立的进程) 。处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU (也有一种特殊的情况就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断。)硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理的进程，中断代码本身也可以被其他的硬中断中断对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在4是为了让调度代码 (或称为调度器) 可以调度多任务。

(2) 软中断
1.软中断的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的。
2.通常，软中断是一些对I/0的请求。这些请求会调用内核中可以调度I/0发生的程序。对于某些设备，I/0请求需要被立即处理，而磁盘I/0请求通常可以排队并且可以稍后处理。根据I/O模型的不同，进程或许会被挂起直到IO完成，此时内核调度器就会选择另一个进程去运行。I/0可以在进程之间产生。并且调度过程通常和磁盘I/0的方式是相同。
3.软中断仅与内核相联系。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行。
4.软中断并不会直接中断CPU。也只有当前正在运行的代码(或进程)才会产生软中断。这种中断是一种需要内核为正在运行的进程去做一些事情(通常为I/0) 的请求。有一个特殊的软中断是Yield调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行

硬中断和软中断的区别
软中断是执行中断指令产生的，而硬中断是由外设引发的。
硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。
硬中断是可屏蔽的，软中断不可屏蔽。
硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。
软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部。


2、中断为什么要区分上半部和下半部？
上半部：
上半部就是中断处理函数，那些处理过程比较快，不会占用很长时间的处理就可以放在上半部完成。
下半部：
如果中断处理过程比较耗时，那么就将这些比较耗时的代码提出来，交给下半部去执行，这样中断处理函数就会快进快出。
linux内核将中断分为上半部和下半部的主要目的就是实现中断处理函数的快进快出，那些对时间敏感、执行速度快的操作可以放到中断处理函数中，也就是上半部。剩下的所有工作就放到下半部去执行，比如，上半部将数据copy到内存中，下半部就执行对数据的处理。


3、中断下半部一般如何实现？
软中断、tasklet、等待队列


4、linux中断的响应执行流程？中断的申请及何时执行(何时执行中断处理函数)？
（1） 发生中断后，CPU执行异常向量vector_irq的代码；
（2）在vector_irq里面，最终会调用中断处理C程序总入口函数asm_do_IRQ();
（3）asm_do_IRQ()根据中断号调handle_irq();
（4）handle_irq()会使用chip的成员函数来设置硬件，例如清除中断，禁止中断，重新开启中断等；
（5）handle_irq逐个调用用户在action链表中注册的处理函数。
　　可见，中断体系结构的初始化，就是构造irq_desc[NR_IRQS]这个数据结构；用户注册中断就是构造action链表；用户卸载中断就是从action链表中去除对应的项。

中断的响应流程: cpu接受中断->保存中断上下文跳转到中断处理历程->执行中断上半部->执行中断下半部->恢复中断上下文
中断的申请request irg的正确位置: 应该是在第一次打开、硬件被告知终端之前

5、Linux 软中断和工作队列的作用是什么？
软中断：不可睡眠阻塞，处于中断上下文，不能进程切换，不能被自己打断。
工作队列：处理进程上下文中，可以睡眠阻塞。

6、中断和轮询哪个效率高？怎样决定是采用中断方式还是采用轮询方式去实现驱动？
中断是CPU处于被动状态下来接受设备的信号，而轮询是CPU主动去查询该设备是否有请求。凡事都是两面性，所以，看效率不能简单的说那个效率高。如果是请求设备是一个频繁请求cpu的设备，或者有大量数据请求的网络设备，那么轮询的效率是比中断高。如果是一般设备，并且该设备请求cpu的频率比较底，则用中断效率要高一些。主要是看请求频率。

7、写一个中断服务需要注意哪些？如果中断产生之后要做比较多的事情你是怎么做的？
中断处理例程应该尽量短，把能放在后半段(tasklet，等待队列等)的任务尽量放在后半段。
写一个中断服务程序要注意快进快出，在中断服务程序里面尽量快速采集信息，包括硬件信息，然后退出中断，要做其它事情可以使用工作队列或者tasklet方式。也就是中断上半部和下半部。
第二：中断服务程序中不能有阻塞操作。应为中断期间是完全占用CPU的（即不存在内核调度），中断被阻塞住，其他进程将无法操作；
第三：中断服务程序注意返回值，要用操作系统定义的宏做为返回值，而不是自己定义的OK，FAIL之类的。

工作队列与tasklet的区别：
工作队列允许睡眠或者重新调度
如果不需要软中断的并行特性，tasklet就是最好的选择



并发与竞争：
1、linux中的同步机制？spinlock与信号量的区别？
①原子操作
②自旋锁
③信号量
④互斥体

自旋锁只能被一个线程持有，只要此线程不释放持有的锁，那么其他的线程就不能获取此锁，会使线程原地打转一直轮询。

信号量可以使线程进入休眠状态，适用于那些占用资源比较久的场合
信号量在得不到锁的时候会休眠，等到可以获得锁的时候，继续执行。
信号量不能用于中断中，因为信号量会引起休眠，中断不能休眠
如果共享资源的持有时间比较短，那就不适合使用信号量了，因为频繁的休眠、切换
线程引起的开销要远大于信号量带来的那点优势


3、什么是死锁？如何避免死锁（每个技术面试官必问）
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去；此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
原因：①系统资源的竞争，系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。
②进程运行推进顺序不合适，进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。

产生死锁的四个必要条件：
互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
不可剥夺条件: 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
循环等待条件: 若干进程间形成首尾相接循环等待资源的关系
这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。



Linux驱动模型：
1、字符设备驱动模型


2、LCD驱动模型


3、总线设备驱动模型


4、输入子系统模型


5、设备驱动模型三个重要成员是？platform总线的匹配规则是什么？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？
设备驱动模型的三个重要成员是总线，驱动，设备。
platfoem总线的匹配规则是：要匹配的设备和驱动都要注册，驱动和设备的匹配规则如下
1.基于设备树风格的匹配
2.匹配ID表(即platform_device设备名是否出现在platform_driver的id表内)
3.匹配platform_device设备名和驱动的名字
4.基于ACPI风格的匹配

Linux内核
1、内核镜像格式有几种？分别有什么区别？
①、vmlinux：Linux内核编译出来的原始的内核文件，elf格式，未做压缩处理。该映像可用于定位内核问题，但不能直接引导Linux系统启动。
②、Image：Linux内核编译时，使用objcopy处理vmlinux后生成的二进制内核映像。该映像未压缩，可直接引导Linux系统启动。
③、zImage：使用gzip压缩Image后，使用objcopy命令生成的Linux内核映像。该映像一般作为uboot的引导映像文件。
④、uImage：在zImage前面增加一个64字节的头，描述映像文件类型，加载位置，大小等信息。该映像是老版本uboot专用的引导映像。

2、内核中申请内存有哪几个函数？有什么区别？
vmalloc 用于申请大块内存，虚拟地址连续，物理地址不一定连续，不能直接用于DMA，在进程地址空间有专门的一块，释放函数 vfree()。
kmalloc 用于申请小内存，由 slab 管理实现，一般至少小于4KB（page）。不能申请大于128K的数据。物理地址和虚拟地址都连续，可用于DMA操作。


3、什么是内核空间，用户空间？
对 32 位操作系统而言，它的寻址空间 (虚拟地址空间，或叫线性地址空间)为 4G (2的32次方)。也就是说一个进程的最大地址空间为 4G。
操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，现在的操作系统一般都强制用户进程不能直接操作内核。具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间。针对 Linux 操作系统而言，最高的 1G 字节(从虚拟地址 0xC0000000 到 0XFFFFFFFF)由内核使用，称为内核空间。而较低的 3G 字节(从虚拟地址 0x00000000 到 0XBFFFFFFF)由各个进程使用，称为用户空间。

对上面这段内容我们也可以这样理解:
每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使用。换句话说就是，最高 1G 的内核空间是被所有进程共享的!

4、为什么需要区分内核空间与用户空间？
为什么需要区分内核空间与用户空间?
在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如清内存、设置时钟等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。

5、什么是内核态和用户态？
当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。

在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 IO 许可位图(I/O Permission Bitmap)中规定的可访问端口进行直接访问。
对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。
对于 Linux 来说，通过区分内核空间和用户空间的设计，隔离了操作系统代码(操作系统的代码要比应用程序的代码健壮很多)与应用程序代码。即便是单个应用程序出现错误，也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊!)。所以，区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性。

6、用户空间与内核通信方式有哪些？
①
get_user(x，ptr) //在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。
put_user(x，ptr) //在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。
Copy_from_userO/copy_to_user0) //主要应用于设备驱动读写函数中，通过系统调用触发。

②信号
从内核空间向进程发送信号，例如用户程序出现重大错误，内核发生信号杀死相应的进程。



7、内核链表为什么具有通用性？


8、linux中系统调用过程？应用程序中open()在linux中执行过程中是如何从用户空间到内核空间？
.应用层调用open函数，在VFS层中找到struct inode结构体，判断是字符设备还是块设备，根据设备号，可以找到对应的驱动程序。
2.在驱动层中，每个字符设备都有一个struct cdev结构体，这个结构体通过struct inode结构体中的icdev把连接起VFS层和驱动层，struct cdev结构体描述了字符设备所有信息，其中最重要的一项就是字符设备的操作函数接口
struct cdev结构体中的struct file结构体记录了操作字符设备的一些函数，比如open read write函数等。
struct file结构体其实是在VFS层的，通过struct file结构体指针指向驱动层的struct file结构体将驱动层函数和和VFS层链接起来
任务完成，VFS层会给应用返回一个文件描述符 (fd) 。这个fd是和struct file结构体对应的.

9、怎样申请大块内核内存？vmalloc 和 kmalloc 有什么区别？
vmalloc 用于申请大块内存，虚拟地址连续，物理地址不一定连续，不能直接用于DMA，在进程地址空间有专门的一块，释放函数 vfree()。
kmalloc 用于申请小内存，由 slab 管理实现，一般至少小于4KB（page）。不能申请大于128K的数据。物理地址和虚拟地址都连续，可用于DMA操作。

10、主要有哪几种内核锁？Linux 内核的同步机制是什么？
自旋锁：spin_lock 忙等，中断中使用
信号量：semxxx down/up write/read
mutex：初始化为1的信号量
读写锁，RCU(read-copy update)

11、Linux 中的用户模式和内核模式是什么含义？
cpu mode，用户模式只能通过系统调用操作硬件资源，内核模式可以直接操作硬件资源


12、copy_to_user()和copy_from_user()主要用于实现什么功能？一般用于file_operations结构的哪些函数里面？
由于内核空间和用户空间是不能互相访问的，如果需要访问就必须借助内核函数进行数据读写。copy_to_user():完成内核空间到用户空间的复制，copy_from_user()：是完成用户空间到内核空间的复制。一般用于file_operations结构里的read,write,ioctl等内存数据交换作用的函数。当然，如果ioctl没有用到内存数据复制，那么就不会用到这两个函数。

13、创建进程的系统调用有哪些？
clone, fork, vfork

14、模块和应用程序分别运行在什么空间？
模块运行在内核空间，应用程序运行在用户空间

15、Linux 中的浮点运算由应用程序实现还是内核实现？
由应用程序实现，对应的数学库函数。

16、模块程序能否使用可链接的库函数？
module 运行在内核空间，不能链接库函数。

17、Linux 通过什么方式实现系统调用？
软件中断，系统调用编号，异常处理程序

 18、linux中内核空间及用户空间的区别？用户空间与内核通信方式有哪些？
内核空间是操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。
用户空间是普通应用程序可访问的内存区域。
在linux中，32位处理器，内存的最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。

用户空间与内核空间的通信一般通过系统调用。


设备驱动
1、请简述主设备号和次设备号的用途。如果执行mknod chartest c 4 64，创建chartest设备。请分析chartest使用的是那一类设备驱动程序。
1）主设备号：主设备号标识设备对应的驱动程序。虽然现代的linux内核允许多个驱动程序共享主设备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。
     次设备号：次设备号由内核使用，用于正确确定设备文件所指的设备。依赖于驱动程序的编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数组的索引。
2）chartest 表示设备节点名，4表示主设备号，c表示要创建的是字符设备(如果是b则表示块设备)，64表示次设备号。



2、字符型驱动设备怎么创建设备文件？
(1)使用命令mknod : mknod /dev/文件名  c 主设备号 次设备号 （查看主设备号：cat /proc/devices）
(2)使用函数创建：int mknod(const char *path, mode_t mode, dev_t dev);
还有UDEV/MDEV自动创建设备文件的方式，UDEV/MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后。在  /etc/init.d/rcS 脚本文件中会执行 mdev -s 自动创建设备节点。


3、设备驱动程序中如何注册一个字符设备？分别解释一下它的几个参数的含义。
注册一个字符设备驱动有两种方法：
1） void cdev_init(struct cdev *cdev, struct file_operations *fops)
该注册函数可以将cdev结构嵌入到自己的设备特定的结构中。cdev是一个指向结构体cdev的指针，而fops是指向一个类似于file_operations结构（可以是file_operations结构，但不限于该结构）的指针.
2） int register_chrdev(unsigned int major, const char *namem , struct file)operations *fopen);
该注册函数是早期的注册函数，major是设备的主设备号，name是驱动程序的名称，而fops是默认的file_operations结构（这是只限于file_operations结构）。对于register_chrdev的调用将为给定的主设备号注册0－255作为次设备号，并为每个设备建立一个对应的默认cdev结构。

4、/dev/下面的设备文件是怎么创建出来的？
(1)使用命令mknod : mknod /dev/文件名  c 主设备号 次设备号 （查看主设备号：cat /proc/devices）
(2)使用函数创建：int mknod(const char *path, mode_t mode, dev_t dev);
还有UDEV/MDEV自动创建设备文件的方式，UDEV/MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在用户态意味着系统要运行之后。在  /etc/init.d/rcS 脚本文件中会执行 mdev -s 自动创建设备节点。


5、Linux设备中字符设备和块设备有什么主要区别？分别举例。
字符设备：字符设备是个能够像字节流（类似文件）一样被访问的设备，由字符设备驱动程序来实现这种特性。字符设备驱动程序通常至少实现open,close,read和write系统调用。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。
块设备：和字符设备类似，块设备也是通过/dev目录下的文件系统节点来访问。块设备上能够容纳文件系统，如：u盘，SD卡，磁盘等。
字符设备和块设备的区别仅仅在于内核内部管理数据的方式，也就是内核及驱动程序之间的软件接口，而这些不同对用户来讲是透明的。在内核中，和字符驱动程序相比，块驱动程序具有完全不同的接口。


6、驱动中操作物理绝对地址为什么要先ioremap？
因为内核没有办法直接访问物理内存地址，必须先通过ioremap获得对应的虚拟地址

7、insmod，rmmod一个驱动模块,会执行模块中的哪个函数？在设计上要注意哪些问题？
insmod加载驱动的时候会执行init()函数，rmmod会执行exit函数
 insmod调用init函数，rmmod调用exit函数。这两个函数在设计时要注意什么？卸载模块时曾出现卸载失败的情形，原因是存在进程正在使用模块，检查代码后发现产生了死锁的问题。要注意在init函数中申请的资源在exit函数中要释放，包括存储，ioremap，定时器，工作队列等等。也就是一个模块注册进内核，退出内核时要清理所带来的影响，带走一切不留下一点痕迹。

8、nand驱动的probe流程


9、Linux驱动开发中，常用的调试方法有哪些？
(1)printk
(2)linux应用程序调试
(3)GDB

10、Linux驱动开发常用函数




11、设备驱动模型三个重要成员是？platform总线的匹配规则是？在具体应用上要不要先注册驱动再注册设备？有先后顺序没？
设备驱动模型三个重要成员是 总线、设备、驱动；
platfoem总线的匹配规则是：要匹配的设备和驱动都要注册，设备可以在设备树里注册，也可以通过代码注册设备，匹配成功会去调用驱动程序里的probe函数（probe函数在这个platform_driver结构体中注册）。

12、如何唯一标识一个设备？
主设备号和次设备号。dev_t，12位表示主设备号，20位表示次设备号。
MKDEV(int major, int minor)用于生产一个 dev_t 类型的对象。

为什么Linux的中断上下文中不能睡眠？
1. 中断上下文无 “进程身份”，无法被调度唤醒
Linux 的睡眠（如schedule()、msleep()）本质是进程主动放弃 CPU，并进入 “等待队列”，需依赖内核调度器在后续时机将其唤醒（如等待的资源就绪时）。
但中断上下文并非进程：
它没有对应的task_struct（进程描述符），不属于任何用户进程或内核线程，调度器无法识别 “该唤醒谁”；
睡眠操作会导致 CPU 陷入 “无主” 状态 —— 既没有进程可调度，也无法返回中断前的上下文，直接引发系统死锁。
2. 破坏中断处理的 “原子性”，导致数据竞争
中断上下文的核心要求是 **“原子执行”**：一旦中断触发，必须在短时间内处理完成，避免打断其他关键任务（尤其是低优先级中断或进程）。
睡眠会强行中断这种原子性：
睡眠期间，CPU 会切换到其他进程，原中断的处理流程被暂停；
若此时其他中断（甚至同类型中断）再次触发，或其他进程修改了中断上下文正在操作的共享数据（如设备寄存器、全局变量），会直接引发数据竞争（如数据错乱、逻辑异常），严重时导致系统崩溃。
3. 可能导致中断 “嵌套失控” 或 “死锁”
Linux 对中断的处理有严格的优先级和嵌套规则（如高优先级中断可打断低优先级中断），但睡眠会打破这一规则：
若中断上下文睡眠时，恰好触发了与当前等待资源相关的另一个中断（如等待磁盘 IO 的中断上下文，又触发了磁盘 IO 完成的中断），会形成循环等待，导致死锁；
睡眠期间，中断掩码（控制中断使能的标志）可能未正确恢复，可能导致部分中断被长期屏蔽，引发 “中断风暴” 或 “硬件无响应”。




